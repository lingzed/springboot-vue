# 简单多表查询

> 多表查询，就是从多张表中查询数据，一个简单的多表查询语句就是在from后面跟上多张表，用,间隔：

```sql
select * from 表1,表2,...
```

> 以员工表和部门表为例，：

![image-20240401211203374](D:\text1\9.MySQL\assets\image-20240401211203374.png)

![image-20240401211442405](D:\text1\9.MySQL\assets\image-20240401211442405.png)

> 虚线左边的是tb_emp的字段，而右边则是tb_dept的字段，从结果来看，我们查询出了两张表的数据，然后我们看一下数据的条数：

![image-20240401211706023](D:\text1\9.MySQL\assets\image-20240401211706023.png)

> 一共95条数据，员工表中有19条数据，部门表中有5条数据，为什么查询出来一共95条数据？

![image-20240401211934661](D:\text1\9.MySQL\assets\image-20240401211934661.png)



## 笛卡儿积

> 我们来分析一下查询结果，在结果中，alice展示了5次，bob展示了5次，emma也展示了5次：

![image-20240401212143805](D:\text1\9.MySQL\assets\image-20240401212143805.png)

> 我们可以发现，每一个员工都展示了5次，为什么展示了5次？我们往后看，发现同一个员工分别和部门表的5个部门进行了一次匹配：

![image-20240401212443745](D:\text1\9.MySQL\assets\image-20240401212443745.png)

> 即每个员工与所有部门进行了一次匹配，有19个员工，5个部门，总共匹配了19*5=95次，因此就有了95条数据，我们称这种现象为'笛卡尔积'
>
> 笛卡儿积指的是有两个集合A和B，A和B它们所有的组合情况，A和B的所有组合情况就相当于A中的每一条数据拿出来与B中的每一条数据进行匹配：

![image-20240401213748687](D:\text1\9.MySQL\assets\image-20240401213748687.png)

> 总数据 = A集合总数据 * B集合总数据
>
> 我们知道，一共员工只有一个部门，所以这个查询结果是不合适的，以alice为例，她所属部门是学工部，也就是说剩下的4个部门是无效数据，是不需要的：

![image-20240401214122543](D:\text1\9.MySQL\assets\image-20240401214122543.png)

> 其实多表查询就是从多张表中查询数据，并且根据业务需要消除掉这些无效的笛卡儿积。
>
> 我们知道，员工表的外键字段关联部门表的id，我们可以此为连接条件，来过滤无效数据：



## 条件过滤

```sql
select * from 表1,表2 where 表1.字段 = 表2.字段
```

![image-20240401214558942](D:\text1\9.MySQL\assets\image-20240401214558942.png)

![image-20240401214626052](D:\text1\9.MySQL\assets\image-20240401214626052.png)

> 在多表查询中，根据查询的形式，将查询分成两大类：
>
> - 连接查询
>   - 内连接：相当于查询A、B交集部分数据
>   - 外连接
>     - 左外连接：查询<font color='yellow'>左表</font>所有数据(包括两张表交集部分)
>     - 右外连接：查询<font color='yellow'>右表</font>所有数据(包括两张表交集部分)
> - 子查询



# 连接查询



## 内连接查询

> 内连接查询，是通过两张表的交集部分进行连接，来查询两张表的数据：

![image-20240402194302735](D:\text1\9.MySQL\assets\image-20240402194302735.png)

> 查询语法有两种：
>
> - 隐式内连接
> - 显示内连接

```sql
-- 隐式
select 字段列表 from 表1,表2 where 条件...;
-- 显示
select 字段列表 from 表1 [inner] join 表2 on 连接条件...;
```

> 上面我们进行简单多表查询寻时使用的就是隐式内连接
>
> 下面我用两个案例进行演示：
>
> 1、查询员工的姓名，和所属的部门名称（使用隐式内连接）

![image-20240402194909054](D:\text1\9.MySQL\assets\image-20240402194909054.png)

![image-20240402194919212](D:\text1\9.MySQL\assets\image-20240402194919212.png)

> 2、查询员工的姓名，和所属的部门名称（使用显示内连接）

![image-20240402195059660](D:\text1\9.MySQL\assets\image-20240402195059660.png)

![image-20240402195113030](D:\text1\9.MySQL\assets\image-20240402195113030.png)

> 我们看查询结果，一共18条数据，但是员工有19个人，还差一共员工，为什么会差一个员工的信息？因为有一个员工并没有分配部门，即该员工的dept_id字段是null，而上面说过内连接是根据两张表的交集建立联系，既然该员工的dept_id是null，自然无法与部门表建立连接，也就查不出这个员工的信息。



## 外连接查询

> 外连接分为两类：
>
> - 左外连接
> - 右外连接

```sql
-- 左外连
select 字段列表 from 表1 left [outer] join 表2 on 连接条件...;
-- 右外联
select 字段列表 from 表1 right [outer] join 表2 on 连接条件...;
```

> 左外来指的是以左表为基准，完全包含左表的数据，同时包含与右表有交集的部分，右外连则反之。
>
> 下面我用两个案例进行演示：
>
> 1、查询<font color='yellow'>所有</font>的员工的姓名和所属部门（使用左外连）

![image-20240402201948233](D:\text1\9.MySQL\assets\image-20240402201948233.png)

![image-20240402201957428](D:\text1\9.MySQL\assets\image-20240402201957428.png)

> 我们可以发现，即使alex没有分配部门，也会被查询出来，这是因为在这个查询中使用了左外连，而这里是员工表作为左表，因此会把左表即员工表的所有信息都查询出来，即使alex没有部门，也会使用null代替。
>
> 接下来，我将员工的部门改变一下，让一些部门下没有员工，让这些员工去其他部门
>
> 2、查询部门表，<font color='yellow'>所有</font>的部门和对应的员工（使用右外连），根据上面的经验，将部门作为右表就会查询出右表的所有数据，即使一些部门下没有员工，也会被查询出来：

![image-20240402203044239](D:\text1\9.MySQL\assets\image-20240402203044239.png)

![image-20240402203052965](D:\text1\9.MySQL\assets\image-20240402203052965.png)

> 这里查询出了19条数据，为什么是19条，因为alex没有部门也就不与部门表相交，那么剩余的18条与部门表相交的员工就会被查询出来，而部门表中人事部是没有员工的，但是作为右表，人事部也会被查询出来，那么一共就是18+1=19条数据。
>
> 左右外连是可以互换的，只需改变左右表的位置即可。



# 子查询

> 子查询就是在sql中嵌套select的语句，称为嵌套查询，也叫子查询：

```sql
select * from t1 where t1的字段 = (select  t2的字段 from t2...);
```

> 子查询的外部语句可以是insert/update/delete/select的任意一个，最为常见的就是select。
>
> 根据子查询的返回结果，我们将子查询分为4类：
>
> - 标量子查询：子查询返回的结果是单个值
> - 列子查询：子查询返回的结果为一列，但可以是多行
> - 行子查询：子查询返回的结果为一行，但可以是多列
> - 表子查询：子查询返回的结果为多行多列



## 标量子查询

> 子查询返回的是一个值(数字、字符串、日期)，最简单的形式
>
> 常见操作符：=、<>、 >、 >=、 <、 <=
>
> 例子：
>
> 1、查询学工部的所有员工信息(使用标量子查询)
>
> 先将学工部的id查询出来，再根据id与dept_id匹配查询员工信息

![image-20240403211408709](D:\text1\9.MySQL\assets\image-20240403211408709.png)

![image-20240403211416274](D:\text1\9.MySQL\assets\image-20240403211416274.png)

> 2、查询在ava之后入职的员工信息

![image-20240403211825192](D:\text1\9.MySQL\assets\image-20240403211825192.png)

![image-20240403211832468](D:\text1\9.MySQL\assets\image-20240403211832468.png)



## 列子查询

> 子查询返回的结果为一列，但可以是多行
>
> 常见操作符：in、not in等
>
> 例子：
>
> 1、查询教研部和咨询部的所有员工信息
>
> 我们先查出学工部和就业部的id，这个数据是一列数据，所以在查询员工信息时需要让dept_id in 这个一列数据

![image-20240403212219696](D:\text1\9.MySQL\assets\image-20240403212219696.png)

![image-20240403212228961](D:\text1\9.MySQL\assets\image-20240403212228961.png)



## 行子查询

> 子查询返回的结果为一行，但可以是多列
>
> 常见操作符：=、<>、in、not in
>
> 例子：
>
> 1、查询与lucy入职日期一致和职位都相同的员工

![image-20240405142623020](D:\text1\9.MySQL\assets\image-20240405142623020.png)

![image-20240405142630229](D:\text1\9.MySQL\assets\image-20240405142630229.png)

> 这条sql出现了两个子查询，分别查询lucy的入职时间和工作，这么写是会影响查询效率的，其实joinDate和job两个条件，我们可以合并在一起成为一个条件，如：

![image-20240405142942108](D:\text1\9.MySQL\assets\image-20240405142942108.png)

> (joinDate,job)就是将两个条件合成一个条件，即joinDate = '2014-08-08' and job = 1和(joinDate, job) = ('2024-08-08',1)是等价的，而 ('2024-08-08',1)又是select joinDate,job from tb_emp where name = 'lucy'的查询结果，因此sql可以改为：

![image-20240405143623540](D:\text1\9.MySQL\assets\image-20240405143623540.png)

![image-20240405143656923](D:\text1\9.MySQL\assets\image-20240405143656923.png)



## 表子查询

> 子查询的结果是多行多列，常作为临时表
>
> 常用操作符：in
>
> 例子：
>
> 1、查询入职日期是"2018-01-01"之后入职的员工，及其部门信息

![image-20240405144811940](D:\text1\9.MySQL\assets\image-20240405144811940.png)

![image-20240405144819187](D:\text1\9.MySQL\assets\image-20240405144819187.png)

> 这里是将查询出日期>"2018-01-01"的视图表作为一张临时表来查询，并与部门表进行隐式内连接。



# 案例

>  1、查询价格低于10元的菜品名称、价格及其菜品分类名称

![image-20240405173231440](D:\text1\9.MySQL\assets\image-20240405173231440.png)

![image-20240405173238472](D:\text1\9.MySQL\assets\image-20240405173238472.png)

> 使用内连接还是外连接，若需求没有明确的要求完全包含某张表的所有数据，那么我们用内连接查询
>
> 2、查询所有价格在10元-50元之间，且状态是起售的菜品，展示菜品的名称、价格、及其菜品的分类(未分配类型的菜品也要展示出来)

![image-20240405173950149](D:\text1\9.MySQL\assets\image-20240405173950149.png)

![image-20240405173957307](D:\text1\9.MySQL\assets\image-20240405173957307.png)

> 这里明确指定了要将未分配类型的菜品展示出来，所以要使用外连接
>
> 3、查询每个分类下最贵的菜品，展示出分类名称、最贵的菜品的价格

![image-20240405174943566](D:\text1\9.MySQL\assets\image-20240405174943566.png)

![image-20240405174950771](D:\text1\9.MySQL\assets\image-20240405174950771.png)

> 先联查出菜品表和分类表的价格和名称，然后按照名称分组求价格最大值
>
> 4、查询各个分类下菜品的状态是起售，且该分类下菜品的总数量>=3的分类名称

![image-20240405175524179](D:\text1\9.MySQL\assets\image-20240405175524179.png)

![image-20240405175530159](D:\text1\9.MySQL\assets\image-20240405175530159.png)

> 5、查询商务套餐A中包含了哪些菜品(展示套餐名称、套餐价格、包含的菜品名称、价格、份数)

![image-20240405192539552](D:\text1\9.MySQL\assets\image-20240405192539552.png)

![image-20240405192545565](D:\text1\9.MySQL\assets\image-20240405192545565.png)

> 6、查询低于菜品平均价格的菜品信息(展示出菜品的名称和价格)

![image-20240405192942440](D:\text1\9.MySQL\assets\image-20240405192942440.png)

![image-20240405192951008](D:\text1\9.MySQL\assets\image-20240405192951008.png)

> 总结一下思路：
>
> 1. 首先分析进行联查时，所涉及到的表结构有哪些
> 2. 然后再分析进行联查时，查询的条件是什么
> 3. 根据1、2分析进行sql编写



# 注意

> - 子查询会多次查询表中数据，所以子查询的效率不高，能使用连接查询就尽量使用连接查询
