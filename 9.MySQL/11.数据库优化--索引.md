# 索引对查询的提升

> 举个例子，有一张600W条数据的商品表：

![image-20240407205902827](D:\text1\9.MySQL\assets\image-20240407205902827.png)

> 现在我们通过商品条码字段sn来查询其中某一条数据：

![image-20240407205944970](D:\text1\9.MySQL\assets\image-20240407205944970.png)

![image-20240407210008851](D:\text1\9.MySQL\assets\image-20240407210008851.png)

> 耗时13秒：

![image-20240407210054590](D:\text1\9.MySQL\assets\image-20240407210054590.png)

> 仅仅查询一条记录就用了13秒，原因很简单，就是因为该表的数据量非常庞大：

![image-20240407210207242](D:\text1\9.MySQL\assets\image-20240407210207242.png)

![image-20240407210226840](D:\text1\9.MySQL\assets\image-20240407210226840.png)

> 一旦表的数据量变大，那么它的查询效率就会降低，数据量越大，查询效率越低，接下来我们需要对上面的sql语句进行优化，以此来提升查询效率。
>
> 如何优化？用索引。

```sql
-- 创建索引
create index 索引名 on 表名(字段名)
```

> 我们给tb_sku表的sn字段建立一个索引：

![image-20240407210656971](D:\text1\9.MySQL\assets\image-20240407210656971.png)

> 建立索引是比较耗时的，600W数据建立索引耗时45秒：

![image-20240407210806370](D:\text1\9.MySQL\assets\image-20240407210806370.png)

> 当然这并不算是一个耗时的操作，因为建立索引时一般是在建表时进行创建，这时的表是没有数据的，而现在的表是有600W条数据的，同时建立索引是一个永久性的操作，一次性能将600W条数据的索引都构建好，不用每次都去操作。
>
> 我们现在再来执行查询：

![image-20240407211345819](D:\text1\9.MySQL\assets\image-20240407211345819.png)

> 耗时6毫秒，索引对查询效率的提升是巨大的



# 索引

> 索引是帮助数据库<font color='yellow'>高效获取数据</font>的<font color='yellow'>数据结构</font>
>
> 这是没有索引时的查询过程：

![image-20240407211925564](D:\text1\9.MySQL\assets\image-20240407211925564.png)

> 当执行select * from user where age = 45时，会拿着45在age这一列从第一行开始进行逐行匹配，直到匹配到45为止：

![image-20240407212423689](D:\text1\9.MySQL\assets\image-20240407212423689.png)

> 找到45之后，还是会继续往后找，因为存在45不是唯一的情况，所以需要将所有数据都遍历一遍，这就是没有索引的情况，这种情况我们称之为全表扫描。
>
> 从全表就能看出，这种方式的性能是很低的，且数据量越大性能越低。
>
> 有索引的查询过程：
>
> 当我们为age建立索引时，数据库就会为age维护一个索引对应的数据结构，这个数据结构会大大提高查询效率。
>
> 如果让你来实现索引，你会选择怎么样的数据结构？没错就是树形结构。比如最为常见的二叉树。
>
> 下面我以二叉树为例，通过该树形结构展示如何提高查询效率，该树形结构中每一个节点都会去关联原始数据，节点的左边要小于该节点，节点的右边要大于该节点，最终的树形结构如下：

![image-20240407213433191](D:\text1\9.MySQL\assets\image-20240407213433191.png)

> 现在的查询就是拿着45与根节点36对比，比36大走右边，比48小走左边就找到了45：

![image-20240407213644624](D:\text1\9.MySQL\assets\image-20240407213644624.png)

> 而45节点又和原始记录进行关联，最终就找到了原始数据。
>
> 在有索引的情况下，我们不用在进行整表扫描，通过几次对比就能找到数据，这个过程是非常高效的。
>
> 之所以上面执行创建索引时用了45秒，是因为数据库需要将sn字段的600W条数据构建成对应的树形结构。
>
> 注意，这里只是以二叉树举例说明创建索引的使用的是树形结构，在MySQL中并不是使用二叉树。



## 优缺点

> 优点：
>
> - 提高数据查询的效率，降低数据库IO的成本
> - 通过索引列对数据进行排序，降低数据排序的成本。降低CPU消耗
>
> 缺点：
>
> - 索引会占用存储空间
> - 索引大大提升了查询效率，但是却降低了insert、update、delete的效率(因为每对一行数据进行增删改操作都会维护树形结构)
>
> 对于这两个缺点其实我们不用担心，因为现在的服务器都是以T为存储单位空间完全够用，而且在一个业务中查询操作占了90%，我们很少对数据进行增删改操作，因此对数据库进行优化一般也是对查询进行优化。



## 结构

> MySQL支持的索引的数据类型有很多，如：Hash索引、B+Tree索引、Full-Text索引等。我们平时所说的索引如果没有特别指明，默认是B+Tree结构组成的索引。
>
> 在说B+Tree之前，我们再来看看二叉树：

![image-20240408195752496](D:\text1\9.MySQL\assets\image-20240408195752496.png)

> 二叉树中左边的节点是小于根节点的，右边则是大于根节点：

![image-20240408200031367](D:\text1\9.MySQL\assets\image-20240408200031367.png)

> 而且根节点的左右两个节点又都是一个二叉树，但是二叉树很容易出现一个问题，就是偏向一边的情况，如果我们保存数据是根据数据的从大到小(从小到大)来保存，那么由这组数据组成的二叉树就是一条单项列表：

![image-20240408200339416](D:\text1\9.MySQL\assets\image-20240408200339416.png)

> 此时很容易看出，其搜索性能会大打折扣。这时我们可以选择平衡二叉树或者红黑树来解决问题：

![image-20240408200540835](D:\text1\9.MySQL\assets\image-20240408200540835.png)

> 红黑树也是一颗平衡二叉树，MySQL并没有采用二叉树或者红黑树，其主要原因是大数据量的情况下，层级较深，检索速度依然慢，因为不管是二叉树还是红黑树，一个节点下只能有两个子节点。



### B+Tree

> 我们再来看B+Tree，B+Tree又叫多路平衡搜索树，结构图如下：

![image-20240408201333616](D:\text1\9.MySQL\assets\image-20240408201333616.png)

> 我没看，蓝色代表key值，每一个节点是可以存储多个key的，如根节点存储了3个key：

![image-20240408201459722](D:\text1\9.MySQL\assets\image-20240408201459722.png)

> 而灰色的代表指针，存储了几个key，就会有几个指针：

![image-20240408201636016](D:\text1\9.MySQL\assets\image-20240408201636016.png)

> 这3个指针分别用来指向下一个磁盘块，也就是黄色部分，在数据库中也将磁盘块叫做页，页是数据库磁盘管理的最小单位，一个页是16KB，这是B+Tree的第一个特点：一个节点可以存储多个key，有n个key就有n个指针。
>
> 一个节点下面就会有n个子节点，这些子节点就是所谓的多路。
>
> 在B+Tree中，上面的节点我们称之为'非叶子节点'，下面的部分称之为'叶子节点'：

![image-20240408202408080](D:\text1\9.MySQL\assets\image-20240408202408080.png)

> 非叶子节点只起到索引数据，查找数据的作用，所有的数据都保存在叶子节点中，也就是绿色的部分：

![image-20240408202648263](D:\text1\9.MySQL\assets\image-20240408202648263.png)

> 所有的key也会出现在叶子节点：

![image-20240408202925338](D:\text1\9.MySQL\assets\image-20240408202925338.png)

> 每个key对应保存一个数据，这就是B+Tree的第二个特点。
>
> 第三个特点：B+Tree是一个多路平衡搜索树，所以他的叶子节点的key是按照从小到大的顺序排列：

![image-20240408203428935](D:\text1\9.MySQL\assets\image-20240408203428935.png)

> 同时在叶子节点中形成了一个双向列表，我们由下个元素能找到下一个元素，反之亦然。
>
> B+Tree的查找过程，假设我们查找53，B+Tree内部是通过二分法查找，53先在跟节点对比，介于38-67之间，走38的指针p2，到p2对应的节点中再进行对比，介于47和55之间，走47的指针p2，到p2对应的叶子节点中找到53对应的值：

![image-20240408204033206](D:\text1\9.MySQL\assets\image-20240408204033206.png)

> 又比如找29：

![image-20240408204148680](D:\text1\9.MySQL\assets\image-20240408204148680.png)



### B+Tree特点：

> - 每个节点可以存储多个key(有n个key，就有n个指针)
> - 所有key都出现在叶子节点中，所有数据都存储再叶子节点中，非叶子节点仅用于索引数据
> - 叶子节点形成了一颗双向链表，便于数据的排序及区间范围查询
>
> B+Tree相较于二叉树，树的层级就比较低，在数据库中一般就3到4层



## 创建索引

```sql
-- 为表中的某个字段创建索引
-- 如果要为多个字段创建索引，使用字段列表中间用,分隔
-- 如果创建唯一索引，使用关键字unique
-- 索引命名建议：idx_表名_字段名
create [unique] index 索引名 on 表名(字段名,...);
```



## 查看索引

```sql
-- 查看这张表中所有索引信息
show index from 表名;
```



## 删除索引

```sql
drop index 索引名 on 表名;
```



# 案例

> 1、为emp表的name字段创建索引：

![image-20240408205823868](D:\text1\9.MySQL\assets\image-20240408205823868.png)

> 2、查看emp的索引信息：

![image-20240408205943711](D:\text1\9.MySQL\assets\image-20240408205943711.png)

![image-20240408205951732](D:\text1\9.MySQL\assets\image-20240408205951732.png)

> 发现有4个索引，第一个索引对应的字段是id，这其实是主键对应的索引，我们指定主键后就会自动创建一个索引，这个索引叫做主键索引，是所有索引中查询性能最高的。
>
> 第二个对应的字段是username，因为我们之前指定过这个字段的约束是唯一约束，所以这里自动创建了一个唯一索引
>
> 第三个是deptId对应的索引，也就是创建外键时自动创建的索引，叫做外键索引
>
> 第四个就是自定义索引
>
> 3、删除name自动对应的索引：

![image-20240408210619569](D:\text1\9.MySQL\assets\image-20240408210619569.png)

![image-20240408210627233](D:\text1\9.MySQL\assets\image-20240408210627233.png)



# 注意

> - 主键索引，在建表时，会自动创建主键索引
> - 添加唯一约束时，会为该字段加上唯一索引
> - 添加外键约束时，会为该字段加上外键索引