> DQL是数据查询语言，是用来查询数据表中的数据的，关键字是：
>
> select



# 查询语法

> 这个语法是查询的基本语法：

```sql
select 
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段
limit
	分页参数;
```

> 这么看起来查询语法非常繁琐，下面我将分部分进行说明。



## 基本查询

```sql
select 
	字段列表
from
	表名列表
```



### 查询多个字段

```sql
select 字段1,字段2,字段3 from 表名;
```

> 查询name和joinDate：

![image-20240318202931623](D:\text1\9.MySQL\assets\image-20240318202931623.png)

![image-20240318202954894](D:\text1\9.MySQL\assets\image-20240318202954894.png)



### 查询全字段

```sql
-- *通配符，表示全字段
select * from 表名;
```

![image-20240318203117500](D:\text1\9.MySQL\assets\image-20240318203117500.png)

![image-20240318203128837](D:\text1\9.MySQL\assets\image-20240318203128837.png)



### 字段别名

```sql
select 字段1 [as 别名1],字段2 [as 别名2] from 表名;
-- 或者
select 字段1 [别名1],字段2 [别名2] from 表名;
```

> 查询username、name、gander字段，别名设为用户名、姓名、性别：

![image-20240318203555908](D:\text1\9.MySQL\assets\image-20240318203555908.png)

![image-20240318203606501](D:\text1\9.MySQL\assets\image-20240318203606501.png)

> 其他字符别名：

![image-20240318203743892](D:\text1\9.MySQL\assets\image-20240318203743892.png)

![image-20240318203759427](D:\text1\9.MySQL\assets\image-20240318203759427.png)



### 去重查询

```sql
-- 相同字段值会去除
select distinct 字段列表 from 表名;
```

> 当我查询一个字段的去重时，如job，非去重：

![image-20240318204417102](D:\text1\9.MySQL\assets\image-20240318204417102.png)

> 去重：

![image-20240318204438179](D:\text1\9.MySQL\assets\image-20240318204438179.png)

![image-20240318204443215](D:\text1\9.MySQL\assets\image-20240318204443215.png)

> 单个字段去重非常好理解，但是当多个字段去重时其表现如何？比如查询name和job时：

![image-20240318204536651](D:\text1\9.MySQL\assets\image-20240318204536651.png)

![image-20240318204558552](D:\text1\9.MySQL\assets\image-20240318204558552.png)

> 可以发现job有重复值，我们再插入一条数据name=alice，job=1，然后执行非去重：

![image-20240318204909870](D:\text1\9.MySQL\assets\image-20240318204909870.png)

![image-20240318204916947](D:\text1\9.MySQL\assets\image-20240318204916947.png)

> 可以发现最后一行多了一条数据同第一条一致，然后再去重：

![image-20240318205000837](D:\text1\9.MySQL\assets\image-20240318205000837.png)

> 1和alice只有一条了，那么可以肯定，distinct是对满足当前所有字段的值都一致的数据去重，只要有一个字段值不一致就不会去重。



## 条件查询

```sql
select 字段列表 from 表名 where 条件列表;
```



### 运算符

> 条件查询的运算符，分为比较运算符和逻辑运算符：

| 比较运算符          | 功能                                   |
| ------------------- | -------------------------------------- |
| >                   | 大于                                   |
| >=                  | 大于等于                               |
| =                   | 等于                                   |
| <=                  | 小于等于                               |
| <> 或 !=            | 不等于                                 |
| between ... and ... | 在某个范围之内(含最小值和最大值)       |
| in(...)             | 在in之后的列表中的值，多选一           |
| like 占位符         | 模糊匹配，_匹配单个字符，%匹配多个字符 |
| is null             | 是null                                 |

| 逻辑运算符 | 功能                       |
| ---------- | -------------------------- |
| and 或 &&  | 并且(多个条件同时成立)     |
| or 或 \|\| | 或者(多个条件任意一个成立) |
| not 或 ！  | 非，不是                   |



### 案例

> 1、查询姓名为alice的员工的信息
>
> 关键字：=

![image-20240319204518103](D:\text1\9.MySQL\assets\image-20240319204518103.png)

![image-20240319204534988](D:\text1\9.MySQL\assets\image-20240319204534988.png)

> 2、查询id<=12的员工信息
>
> 关键字：<=

![image-20240319204715999](D:\text1\9.MySQL\assets\image-20240319204715999.png)

![image-20240319204726408](D:\text1\9.MySQL\assets\image-20240319204726408.png)

> 3、查询没有分配职位的员工信息
>
> 关键字：is null

![image-20240319204922502](D:\text1\9.MySQL\assets\image-20240319204922502.png)

![image-20240319204933674](D:\text1\9.MySQL\assets\image-20240319204933674.png)

> 4、查询有职位的员工信息
>
> 关键字：is not null

![image-20240319205134571](D:\text1\9.MySQL\assets\image-20240319205134571.png)

![image-20240319205144881](D:\text1\9.MySQL\assets\image-20240319205144881.png)

> 5、查询密码不是123456的员工信息
>
> 关键字：!= 或 <>

![image-20240319205409854](D:\text1\9.MySQL\assets\image-20240319205409854.png)

![image-20240319205420435](D:\text1\9.MySQL\assets\image-20240319205420435.png)

> 6、查询入职日期在2000-01-01(包含)到2013-01-01(包含)之间的员工信息
>
> 关键字：between ... and ... 或 >= and <=

![image-20240319205646648](D:\text1\9.MySQL\assets\image-20240319205646648.png)

![image-20240319205655465](D:\text1\9.MySQL\assets\image-20240319205655465.png)

> 7、查询入职日期在2000-01-01(包含)到2013-01-01(包含)之间，且性别为女的员工信息
>
> 关键字：between ... and ... and 或 >= and <= and

![image-20240319210113697](D:\text1\9.MySQL\assets\image-20240319210113697.png)

![image-20240319210121843](D:\text1\9.MySQL\assets\image-20240319210121843.png)

> 8、查询入职位是2、3的员工信息
>
> 关键字：in(...) 或 or

![image-20240319210404222](D:\text1\9.MySQL\assets\image-20240319210404222.png)

![image-20240319210411109](D:\text1\9.MySQL\assets\image-20240319210411109.png)

> 9、查询姓名为3个字的员工信息
>
> 关键字：like '_ _ _'

![image-20240319210820962](D:\text1\9.MySQL\assets\image-20240319210820962.png)

![image-20240319210827847](D:\text1\9.MySQL\assets\image-20240319210827847.png)

> 10、查询首字母是e的员工信息
>
> 关键字：like 'e%'

![image-20240319211009536](D:\text1\9.MySQL\assets\image-20240319211009536.png)

![image-20240319211018478](D:\text1\9.MySQL\assets\image-20240319211018478.png)



## 分组查询

```sql
select 
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表;
```

> 分组查询一般结合聚合函数一起使用。



### 聚合函数

> 将表中某一列作为整体，进行纵向计算：

```sql
select 聚合函数(字段列表) from 表名;
```

| 函数    | 功能     |
| ------- | -------- |
| count() | 统计个数 |
| max()   | 最大值   |
| min()   | 最小值   |
| avg()   | 平均值   |
| sum()   | 求和     |

> 1、count()，统计字段的个数，该字段不为null才计入统计，否则不计入，比如我统计id的个数：

![image-20240319212335030](D:\text1\9.MySQL\assets\image-20240319212335030.png)

> 再统计job的个数：

![image-20240319212445249](D:\text1\9.MySQL\assets\image-20240319212445249.png)

> job有一个null值，因此没有计入统计，总数就是17。
>
> count(true值)，依然是统计个数，如：count(常量)、count(字符)、count(true)：

![image-20240319213026019](D:\text1\9.MySQL\assets\image-20240319213026019.png)

![image-20240319213035157](D:\text1\9.MySQL\assets\image-20240319213035157.png)

> count(*)也是统计表数据的总条数，<font color='yellow'>推荐使用count(\*)</font>，MySQL底层对其做了优化：

![image-20240319213354378](D:\text1\9.MySQL\assets\image-20240319213354378.png)

> 2、统计入职日期最小值：

![image-20240319213621696](D:\text1\9.MySQL\assets\image-20240319213621696.png)

> 3、统计入职日期最大值：

![image-20240319213726191](D:\text1\9.MySQL\assets\image-20240319213726191.png)

> 4、统计id平均值：

![image-20240319213903732](D:\text1\9.MySQL\assets\image-20240319213903732.png)

> 5、对id求和：

![image-20240319214012546](D:\text1\9.MySQL\assets\image-20240319214012546.png)

### 案例

> 分组查询一般结合聚合函数一起使用，用group by对需要分组的字段进行分组，分组之后需要条件过滤使用having。
>
> 1、根据性别分组，统计男女员工的数量：

![image-20240320195603518](D:\text1\9.MySQL\assets\image-20240320195603518.png)

> 我直接分组后查询所有字段，然后报错了，为什么呢？因为我是按照性别进行的分组，性别只有男和女两个，因此把性别为男的员工归为一组，把性别为女的员工归为另一组，现在MySQL查询所有字段，在男这个组别中MySQL应该给我展示哪个员工的所有字段？同样在女这个组别中它又该展示哪个员工的所有字段？这存在歧义，事实上应该展示哪些员工的所有字段，是毫无意义的。
>
> 所以在分组查询中的字段列表是有规定的：
>
> - <font color='yellow'>要么是分组字段列表</font>
> - <font color='yellow'>要么是聚合函数</font>

![image-20240320200442314](D:\text1\9.MySQL\assets\image-20240320200442314.png)

> 2、先查询入职时间在2015-01-01(包含)以前的员工，再对结果按职位分组，获取员工数量大于等于2的职位：

![image-20240320201041351](D:\text1\9.MySQL\assets\image-20240320201041351.png)

> 这个查询需要用到where和having，where是再分组之前进行条件过滤，按职位进行分组，分组之后没有日期这个字段，所以需要在分组前把日期不满足的过滤掉，having是对分组后的数据进行条件过滤，分组后可以统计数量，因此用having过滤数量小于2的职位。



## 排序查询

```sql
select 
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段;
```

> 排序方式：
>
> - ASC：升序(默认) (从低到高往下排)
> - DESC：降序 (从高到低往下排) (没错跟查询表结构的desc一样的单词)
>
> 另一种方式：也可以直接用 + 和 - 来排序，比如根据字段A排序，A(+A)是根据A的升序排序，-A是根据A的降序排序。



### 案例

> 1、根据入职时间，对员工进行升序排序：

![image-20240320203048661](D:\text1\9.MySQL\assets\image-20240320203048661.png)

> 使用A(+A)升序：

![image-20240320203228764](D:\text1\9.MySQL\assets\image-20240320203228764.png)

> 2、入职时间降序排序：

![image-20240320203318244](D:\text1\9.MySQL\assets\image-20240320203318244.png)

> 3、入职时间升序排序、入职时间相同按更新时间降序排序：

![image-20240320203540293](D:\text1\9.MySQL\assets\image-20240320203540293.png)

## 分页查询

```sql
select 
	字段列表
from
	表名列表
where
	条件列表
group by
	分组字段列表
having
	分组后条件列表
order by
	排序字段
limit
	分页参数;
```

> 分页参数有两个：

```sql
-- 起始索引: 从哪条数据开始查询，索引从0开始
-- 查询记录数: 这一页展示多少条数据
limit 起始索引,查询记录数;
```

> (limit index, pageSize)起始索引index和记录数pageSize与页数page的关系：
>
> <font color='yellow'>index = (page - 1) * pageSize</font>



### 案例

> 1、从索引0开始，查询员工数据，每页展示5条记录：

![image-20240320204826597](D:\text1\9.MySQL\assets\image-20240320204826597.png)

> 2、查询第一页员工数据，每页只展示5条，根据公式m = (p-1)*n,得第一页起始索引为0：

![image-20240320204826597](D:\text1\9.MySQL\assets\image-20240320204826597.png)

> 3、查询第二页员工数据，每页只展示5条，由公式得起始索引为5：

![image-20240320205540625](D:\text1\9.MySQL\assets\image-20240320205540625.png)

> 4、查询第三页员工数据，每页只展示5条，由公式得起始索引为10：

![image-20240320205754697](D:\text1\9.MySQL\assets\image-20240320205754697.png)



# 案例

> 1、分页查询首字母是a，性别男，入职时间在'2000-01-01'到'2015-12-31'之间的员工信息，每页展示10条数据，并按照入职时间倒叙排序：

![image-20240321202200605](D:\text1\9.MySQL\assets\image-20240321202200605.png)

![image-20240321202212453](D:\text1\9.MySQL\assets\image-20240321202212453.png)



## 流程控制函数



### if()

> 2、统计员工性别信息，1显示为男性员工，2显示为女性员工。
>
> 这需要使用sql中的流程控制函数，if()，类似于三元运算符：

```sql
if(条件表达式,true取值,false取值);
```

> 其sql如下：

![image-20240321203450412](D:\text1\9.MySQL\assets\image-20240321203450412.png)

![image-20240321203458467](D:\text1\9.MySQL\assets\image-20240321203458467.png)



### case

> 3、统计员工职位信息，1显示c，2显示班主任，3显示教导主任。
>
> 我们先查询job分组后的统计情况：

![image-20240321204130055](D:\text1\9.MySQL\assets\image-20240321204130055.png)

![image-20240321204136302](D:\text1\9.MySQL\assets\image-20240321204136302.png)

> 讲师有9人，班主任有4人，教导主任有4人，还有1人没有分配职位，我们需要让job显示为讲师、班主任和教导主任，如果使用if()分支就会太多，这里可以使用另一个流程控制函数case，case类似于java中的switch：

```sql
-- 如果表达式=值1，取结果1，如果表达式=值2，取结果2...否则取最后结果
case 表达式 
when 值1 then 结果1 
when 值2 then 结果2... 
else 最后结果
end;
```

> 其sql如下：

![image-20240321205255461](D:\text1\9.MySQL\assets\image-20240321205255461.png)

![image-20240321205312094](D:\text1\9.MySQL\assets\image-20240321205312094.png)

# 注意

> - 查询时不建议使用*，因为字段不直观，且影响查询效率
> - 条件查询判断null值时建议使用is null，不要使用= null，= null查询结果有误
> - null值不参与所有聚合函数运算
> - 统计表数据条数：count(*)、count(字段)、count(常量)、count(字符)、count(true)，推荐使用count(\*)
> - 分组查询，查询返回的字段一般是聚合函数和分组字段，查询其他字段无意义
> - where是对分组前的数据进行过滤，having是对分组后的数据进行过滤
> - where不能对聚合函数进行判断(where后面不能跟聚合函数)，having可以
> - 分组的执行顺序：where > 聚合函数 > having
> - 多字段排序，第一个字段同序时，才会排序第二个字段，第二个字段同序时，才会排序第三个字段......
> - 起始索引m、页码p、每页记录数n，有公式：m = p * (n - 1)
> - 分页查询是数据库得方言，不同库有不同实现，MySQL中是limit
> - 如果查询第一页数据，起始索引可以省略，直接limit n
> - 不要忘记case后面还有一个end结束符