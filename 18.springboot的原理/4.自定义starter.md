# 分析

> 自定义starter
>
> starter就是springboot中的起步依赖。springboot本身为我了提供了很多的起步依赖，为什么我们还要自定义starter呢？因为不是所有第三方依赖都提供了整合springboot的起步依赖。
>
> 比如，之前使用的OSS，阿里云官方并没有提供OSS的起步依赖。但是OSS适用性很广泛，在很多项目中都能使用。如果没有起步依赖，那么在这些项目中我们需要重复进行OSS的依赖引入，编写工具类等操作，非常麻烦。
>
> 在实际开发中，经常会定义一些公共组件，提供给各个项目团队使用。而在SpringBoot的项目中，一般会将这些公共组件封装为SpringBoot的starter。
>
> starter命名规范：
>
> 如果是springboot提供的，命名以 "spring-boot-starter-功能" 的格式
>
> 如果是第三方提供的，命名以 "功能-spring-boot-starter"  的格式
>
> 比如：

![image-20240526104514949](E:\springboot-vue\18.springboot的原理\assets\image-20240526104514949.png)

![image-20240526104607168](E:\springboot-vue\18.springboot的原理\assets\image-20240526104607168.png)

> ok，现在我们来看mybatis的依赖：

![image-20240526105318315](E:\springboot-vue\18.springboot的原理\assets\image-20240526105318315.png)

> 发现一个java代码都没有，这个starter就只做了一件事，就是将mybatis开发所需要的依赖配置在POM中：

![image-20240526105349325](E:\springboot-vue\18.springboot的原理\assets\image-20240526105349325.png)

> 这其中，有一个依赖比较特殊：

![image-20240526105418183](E:\springboot-vue\18.springboot的原理\assets\image-20240526105418183.png)

> 他是mybatis的自动配置依赖，在mybatis依赖的上面：

![image-20240526105507127](E:\springboot-vue\18.springboot的原理\assets\image-20240526105507127.png)

> 打开，里面配置了一些类和注解：

![image-20240526105539960](E:\springboot-vue\18.springboot的原理\assets\image-20240526105539960.png)

> 这个自动配置依赖里面就是声明了一些Bean和配置类，上文说过springboot要完成自动配置需要加载两份配置文件：

![image-20240526110104865](E:\springboot-vue\18.springboot的原理\assets\image-20240526110104865.png)

> 这些配置类就声明在这些文件中，从而能被springboot识别完成自动配置：

![image-20240526110156881](E:\springboot-vue\18.springboot的原理\assets\image-20240526110156881.png)

> 这就是为什么我们在使用mybatis的时候没有显示的声明@Import或@Enable类注解，因为mybatis依赖中配置了spring.factories和AutoConfiguration.imports这两个文件，由springboot去识别这两个文件，就不需要我们显示的声明@Import了。之前我们模拟第三方库的导入，虽然最后使用了@Enable类的注解来简化了导入的书写，但是依然要在启动类上声明@Enable，如果我们在第三方库中也定要这样两个文件，同时配置好需要装配的类那么springboot就能帮我们完成配置，而不需要我们手动去声明@Enable类注解。
>
> 我们在自定义starter的时候，按照规范，需要定义两个模块，第一个模块是starter模块，这个模块只用来做依赖管理：

![image-20240526111444678](E:\springboot-vue\18.springboot的原理\assets\image-20240526111444678.png)

> 我们把需要的依赖都定义在starter中。在starter中还引入了一个依赖，就是autoconfigure，在这个包中就来完成自动配置的操作：

![image-20240526111622744](E:\springboot-vue\18.springboot的原理\assets\image-20240526111622744.png)

> 最终在starter中要引入autoconfigure，项目开发中只需引入starter即可，因为autoconfigure会传递过来。



# 案例

> 需求：
>
> 自定义aliyun-oss-spring-boot-starter，完成阿里云OSS操作工具类AliyunOSSUtils的自动配置。
>
> 目标：
>
> 引入起步依赖引入之后，要想使用阿里云OSS，注入AliyunOSSUtils直接使用即可。
>
> 步骤：
>
> 1. 创建starter模块，其中引入OSS相关依赖
> 2. 创建autoconfigure模块，在starter中引入autoconfigure
> 3. 在autoconfigure中完成自动配置的操作，需要定义自动配置文件META-INF/spring/ xxxx.imports，我们这里不定义spring.factories
>
> 创建starter模块：

![image-20240526120737354](E:\springboot-vue\18.springboot的原理\assets\image-20240526120737354.png)

![image-20240526120749223](E:\springboot-vue\18.springboot的原理\assets\image-20240526120749223.png)

> pom中的信息可以删除，比如描述信息：

![image-20240526120938725](E:\springboot-vue\18.springboot的原理\assets\image-20240526120938725.png)

> 单元测试也可以删除：

![image-20240526120959811](E:\springboot-vue\18.springboot的原理\assets\image-20240526120959811.png)

> 插件也可以删除：

![image-20240526121039838](E:\springboot-vue\18.springboot的原理\assets\image-20240526121039838.png)

> starter仅仅是依赖管理，没有任何的java代码，所以目录可以删除，但是别把.iml文件删除了，这是idea的配置文件。如果没有.iml文件，就点两下ctrl：

![image-20240526121517005](E:\springboot-vue\18.springboot的原理\assets\image-20240526121517005.png)

> 点Project，选择项目模块：

![image-20240526121555196](E:\springboot-vue\18.springboot的原理\assets\image-20240526121555196.png)

> 输入mvn idea:module运行：

![image-20240526121626992](E:\springboot-vue\18.springboot的原理\assets\image-20240526121626992.png)

![image-20240526121733914](E:\springboot-vue\18.springboot的原理\assets\image-20240526121733914.png)

> 然后和删除其他目录：

![image-20240526121822727](E:\springboot-vue\18.springboot的原理\assets\image-20240526121822727.png)

> 然后创建autoconfigure模块：

![image-20240526122016436](E:\springboot-vue\18.springboot的原理\assets\image-20240526122016436.png)

![image-20240526122044909](E:\springboot-vue\18.springboot的原理\assets\image-20240526122044909.png)

> pom如法炮制，描述信息、单元测试和插件都可以删除：

![image-20240526122550519](E:\springboot-vue\18.springboot的原理\assets\image-20240526122550519.png)

> 目录可删除，保留src：

![image-20240526123639475](E:\springboot-vue\18.springboot的原理\assets\image-20240526123639475.png)

> 删除启动类：

![image-20240526123655198](E:\springboot-vue\18.springboot的原理\assets\image-20240526123655198.png)

> 测试类删除：

![image-20240526123834239](E:\springboot-vue\18.springboot的原理\assets\image-20240526123834239.png)

> 好，两个模块就创建完成了。
>
> 然后在starter中引入autoconfigure模块：

![image-20240526124041806](E:\springboot-vue\18.springboot的原理\assets\image-20240526124041806.png)

> 下面我们在autoconfigure中配置AliyunOSSUtils这个工具类。
>
> 首先引入OSS的依赖：

![image-20240526124337675](E:\springboot-vue\18.springboot的原理\assets\image-20240526124337675.png)

> 将之前的OSS工具类拷贝过来：

![image-20240526124532933](E:\springboot-vue\18.springboot的原理\assets\image-20240526124532933.png)

> 报错了，一个一个来解决：

![image-20240526124644126](E:\springboot-vue\18.springboot的原理\assets\image-20240526124644126.png)

> lombok依赖和web起步依赖没有引入，我们引入：

![image-20240526124819889](E:\springboot-vue\18.springboot的原理\assets\image-20240526124819889.png)

![image-20240526124835462](E:\springboot-vue\18.springboot的原理\assets\image-20240526124835462.png)

> 然后把@Component删除，为什么要删除呢？因为我们的目的是让springboot自动配置，也就是不让用户手动的去启动类上配置扫描，既然都无法配置扫描，也就扫描不到@Component，那它自然就没用了。没了@Component自动注入也失效，一起删除了：

![image-20240526125909393](E:\springboot-vue\18.springboot的原理\assets\image-20240526125909393.png)

> 我们需要有一个配置类来生成AliOSSUtils的Bean：

![image-20240526130131406](E:\springboot-vue\18.springboot的原理\assets\image-20240526130131406.png)

> 然后再来看AliOSSUtils，它的成员变量aliOSSProperties，之前是通过自动注入的方式来得到值，现在自动注入删除了，那么它就是null，我们需要解决这个问题。
>
> 而且AliOSSProperties再我们删除@Component后报错了，因为@ConfigurationProperties需要类声明@Component，换句话说@ConfigurationProperties需要作用在Bean上。

![image-20240526130501574](E:\springboot-vue\18.springboot的原理\assets\image-20240526130501574.png)

> 我们如何解决上面两个问题？只需要让AliOSSProperties成为Bean即可，成为Bean后@ConfigurationProperties不会报错，而且在Bean方法中我们可以很容易进行依赖注入，如此我们可以将AliOSSProperties作为aliOSSUtils方法的形参来注入AliOSSProperties，而恰好AliOSSUtils成员变量aliOSSProperties是AliOSSProperties类型的，因此我们可以调用AliOSSUtils的set方法将注入的AliOSSProperties赋值给aliOSSProperties。
>
> 最终的问题就是如何让AliOSSProperties成为Bean？我们可以使用@Import，一旦将AliOSSProperties导入，那么spring容器就会将AliOSSProperties变成Bean：

![image-20240526131700740](E:\springboot-vue\18.springboot的原理\assets\image-20240526131700740.png)

> 不报错了：

![image-20240526131716496](E:\springboot-vue\18.springboot的原理\assets\image-20240526131716496.png)

> Bean方法改一下：

![image-20240526131818150](E:\springboot-vue\18.springboot的原理\assets\image-20240526131818150.png)

> 这是使用@Import的方法，我们还可以使用@EnableConfigurationProperties注解。
>
> Enable字样说明它底层封装了@Import：

![image-20240526132826500](E:\springboot-vue\18.springboot的原理\assets\image-20240526132826500.png)

> 所以它的作用也是将类导入，成为Bean，它只能作用于声明了@Configuration的类也就是配置类上以及声明了@Bean的方法也就是Bean方法上。对于导入properties这样的类我们更推荐使用@EnableConfigurationProperties：

![image-20240526133352971](E:\springboot-vue\18.springboot的原理\assets\image-20240526133352971.png)

> 然后我要将AliOSSAutoConfiguration配置在META-INF/spring/ xxxx.imports文件中，方便springboot自动配置。
>
> 在resources下创建META-INF/spring，注意字母一定不要写错。

![image-20240526133814756](E:\springboot-vue\18.springboot的原理\assets\image-20240526133814756.png)

> 创建文件：org.springframework.boot.autoconfigure.AutoConfiguration.imports

![image-20240526133906503](E:\springboot-vue\18.springboot的原理\assets\image-20240526133906503.png)

> 配置需要自动配置的类，全类名：

![image-20240526133952715](E:\springboot-vue\18.springboot的原理\assets\image-20240526133952715.png)

> 到此，starter和autoconfigure就定义完成了。
>
> 测试，这里有一个测试工程：

![image-20240526134243570](E:\springboot-vue\18.springboot的原理\assets\image-20240526134243570.png)

> 有一个上传的源码：

![image-20240526134316532](E:\springboot-vue\18.springboot的原理\assets\image-20240526134316532.png)

> 现在引入我们封装好的起步依赖：

![image-20240526134417896](E:\springboot-vue\18.springboot的原理\assets\image-20240526134417896.png)

> 然后配置OSS需要的配置信息：

![image-20240526134730037](E:\springboot-vue\18.springboot的原理\assets\image-20240526134730037.png)

> 使用这个工具类：

![image-20240526134900026](E:\springboot-vue\18.springboot的原理\assets\image-20240526134900026.png)

> 运行测试：

![image-20240526172848399](E:\springboot-vue\18.springboot的原理\assets\image-20240526172848399.png)

> 成功，断点测试：

![image-20240526173000549](E:\springboot-vue\18.springboot的原理\assets\image-20240526173000549.png)

> 成功注入。